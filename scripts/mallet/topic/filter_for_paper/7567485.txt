To put it briefly: no.A little less briefly, then.  ;)  It is absolutely possible to create code that these tools in general, and Coverity in particular, will have difficulty analyzing . . . but you really have to work at it.  Seriously, these guys are good.  It's a bit like the "arms race" in building vs. breaking crypto.  These guys have been there, they've seen all the moves, they know all the countermoves.  Sure, if you load up your code with runtime-assigned function pointers and code that only executes if the last five iterations of a loop each went through specific code paths themselves, then that's going to cause some problems, but most programmers are unlikely to "win" that battle.However, this particular bug looks like it's in the absolute easiest category.  Any static analyzer should have caught it.  As others have pointed out, the real problem is false positives.  If it was caught, but the report was buried in hundreds or thousands of crappy reports about things that actually aren't problems, then it might as well not have been caught.  That's why the pros at this spend as much time writing code to eliminate false positives as they do writing code to find new things.  In every project I've worked on that used static analysis, the weak link in the chain has been between reporting and remedy, not in the analysis itself.