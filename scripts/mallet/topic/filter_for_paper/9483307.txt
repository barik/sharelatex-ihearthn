Weird to see references to soft typing (something quite old that didn't quite work out) and no references to the much more recent Diamondback Ruby: http://www.cs.umd.edu/projects/PL/druby/
It was a research project from the fine folks at the university of Maryland but it lost steam because Ruby is so dynamic that its very very hard to write static analysis tools for it.http://www.cs.purdue.edu/homes/jv/events/PBD13/slides/JeffFo...There are some misconceptions about the the Soft Typing approach though that I think I should clear out a bit:* What a soft typing system does is use type inference techniques to try to figure out what locations in the program might raise dynamic type errors (accessing inexistent methods, etc).* Soft typing systems do not check the types of function parameters and return values (since just passing a value around never cause the itnerpreter to throw an error). Some non-soft type systems might check though, adding runtime contract checks if needed.* Soft typing can guarantee safety if you write your program in a way where the type checker manages to infer a static type for everything.* On the other hand, writing things in a way that satisfies the type inferencer can be very hard. And to acomodate the flexibility of dynamic languages the type system might evolve into something quite complex. This is an even larger issue for Ruby, which is highly dynamic and has no formal spec.* The 1991 soft typing paper focuses a lot on speed because back then dynamic type checks were a big reason for the slowness of dynamic language implementations. Nowadays we have tracing JITs (which "inline" away all the type checks, method dispatches, and so on) so there is less of a need to use type inference to speed things up.