- Visual representation of the code structure- Ability to select any symbol and find semantic uses of it- For OO code, being able to visuallize the OO graph usage of certain symbols- Refactoring across the whole project with semantic knowledge (no, search/replace does does not cut it)- Navigation in third-party libraries deployed in binary format- Code completion for static/dynamic languages, while showing tooltip documentation- Graphical visualization of data structures on the debugger- Background compilation with static analysis- unit test debugging infrastructure- integration with modelling tools- integration with SCM tooling and being able to interact with them directly from the editor. For example, generating a blame file, with navigation across the file revisions.- integration  with continuous integration servers- integration of developer workflow with task management serversAs an example of such developer workflows, have the IDE talk to Jira, edit the code, automatically bundle it in a workflow that binds the code changes to the Jira issue being worked on, get a Jenkins notification after the code is checked in and gone through the CI system.Sure you can get part of it in Emacs, after spending a week configuring plugins, with different levels of maturity, and in the end it is still mostly textual.