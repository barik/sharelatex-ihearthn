geocar's response is pretty good, but I am going to disagree on some points.Hyperlinked call graphs: nope.  Never needed it, don't know how to generate them for any language I use.  Emacs can't do it, but neither can anything else.  Write the code to do the work, and Emacs will support it in about 30 seconds.All use of a given symbol: same problem.  The static analysis for this is Really Hard, and it would provide me with near-zero value.Background compilation: yup.  Supported by pretty much every mode.Refactoring: I've used Eclipse, but I've never had good luck with its refactoring tools.  The automated refactorings are almost what I want, but since exactly what I want is so simple, I just do it manually.  If you are renaming your classes everyday and you have to change the name in 1000 files, you have two problems that can't be solved by an IDE.Keyword completion: excellent.  I was using Eclipse today, and there is a noticeable delay between when I press M-/ and when the keyword was completed.  I eventually learned  to not use that feature, because I can type faster than the auto-completion can "intelligently select" the right keyword.Emacs is instantaneous, and right as often as anything else.  And I can expand things other than symbols, like long words in the documentation, or filenames in string literals, etc.As for integration, I find Emacs to be quite well integrated for the work I do.  A few weeks ago, I was writing a Haskell app for use on Windows.  I was really not looking forward to it, until I realized that all the Haskell functionality works perfectly on Windows.  I never needed to leave Emacs; I could test my code (interactively or automatically) from the GHCi REPL and I could build binaries and docs with M-x compile.  Of course, it's just one keystroke to move to compilation errors (in both cases). If I needed to poke around in a shell, I just used Eshell, which works the same on every platform.  Everything you need to do is tightly integrated and very fast.Working with Perl is just as nice; one keystroke runs the test suite in a nearby eshell, another just runs the tests that pertain to the current file.  Anything I want to do is usually one or two keys away, and a shell to do something complicated is just as easy to get to.  (For me, C-x C-x switches between the shell and the most-recently-used buffer.  Fast!)Their UI's tend to be a lot more powerful because they are not designed to be run on windowless environments.Not true.  But one thing that's nice about Emacs is that you can run Emacs in the background and connect to it multiple times.  If your X session dies, no information is lost.  If you are poking around in a shell, you just "emacsclient -t file" (which I alias to "ec file") and you are instantly working with that file in your normal Emacs session.for large projects I use an IDE with a Vim emulation pluginThat means you are probably unaware of about 90% of Vim's features.  I've watched many experienced Vim users try to use various vi emulation plugins for Eclipse, and there is always a lot of cursing involved.  They eventually just invoke Eclipse functions from vim instead.The underlying theme here is that IDEs make tasks that you perform once or twice a week really simple.  The "traditional editors" don't do much about that; instead they make the things you do 10,000 times a day really really simple.(One other thing I notice is that IDE users tend to ignore features that Vim and Emacs have and dismiss them as unnecessary, while Emacs/Vim users steal the good features from IDEs as often as possible.)In conclusion, you don't know much about Emacs.