Well,  the advantage of a language like Java or C# is that the IDE knows the types of objects,  so,  for instance,  it can autocomplete method and property names.  Because introspection is used rarely in static languages,  IDEs can do automated refactoring operations and KNOW that they found all the (non-introspection) references that are affected.It's certainly possible to parse PHP, Python or Ruby into an abstract syntax tree (OK,  Perl is a little harder) but practically very few people do metaprogramming at that level,  even when it's officially supported. (C# and VB have had "expression trees" for a few years now and they're barely used.)Part of the appeal of LISP is that you can pretend Noam Chomsky was never born and never need to learn how to write parsers or deal with the data structures that they spit out.Any kind of extreme metaprogramming is going to defeat 'reasoning-in-code'.  For instance,  in LISP I can easily implement a new kind of control structure...  Because 'understanding' a program in general (rather than running it) is an undecidable problem,  it's clear that an IDE will ultimately get bogged down.I've written a lot of PHP lately in a metaprogramming-heavy framework that uses magic methods to 'create' new properties and methods.  The way this is done is systematic,  and an IDE could probably be loaded with rules that would help it 'understand' this usage,  but so far as I do this kind of code analysis,  it's going to be in command-line tools that are cheap to develop compared to GUI tools.