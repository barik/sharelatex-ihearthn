I looked at http://www.chessvibes.com/plaatjes/rybkaevidence/ZW_Rybka_Fr... . It happens to be the one mentioned as biased evidence in this chessbase article, though I picked it because it was a PDF and not an RTF file.This is the the one which has a side-by-side comparison of what appears to be two pieces of code. One of which is "static const int KnightBackRankOpening = 0;"    for (sq = 0; sq < 64; sq++) {
        P(piece,sq,Opening) += KnightRank[square_rank(sq)] * KnightBackRankOpening;
    }

That appears to damning, but as the chessbase article points out, there's no source for the Rybka case, only reverse engineering. Since KnightBackRankOpening is "static const int 0" (can you really reverse engineer a "const" from machine code?), you would expect any half-decent optimizing compiler to remove that whole chunk of code.In other words, this seemingly indicting code is a faade; a functionally equivalent implementation constructed to maximize similarity. Granted, the PDF does say "The code shown here is simply the functional equivalent" and "Fruit and Rybka have functionally identical code here too," I looked at the code and the biggest similarity is that both code snippets are rendered in the same style. I don't see any copying. I see different tunings (eg, different weight parameters), and even though both tools are working in the same data representation and algorithm space, I see different implementations of those algorithms.I find the chessbase article to be much more convincing than the results of the original investigation.What would convince me otherwise is the same analysis of other modern chess programs, to show that they don't use the same approach.