>I think that's a broad mischaraterization of functional programmingYes, but it's a common one, because its a correct characterization of Haskell and Haskell-derived languages. Functional programming is very popular and used all the time. Consider jQuery, SQL or LINQ. Consider things like Facebook's react library. Functional programming is a very usefull tool, in a much larger toolset.But it has a bad reputation by being associated with the language design mess that is Haskell. And here we have a derived language, making it even worse. The problem is not the functional nature of the language. It's the syntax rooted in ancient (paper) math combined with lazy evalution, and the illusions perpetuated by their followers.To illustrate just how far anti-human this Haskell dialect is: it uses greek symbols!. This alone excludes 99.99% of the world population. The majority of the world population will not be able to even phrase the question "what does that symbol mean" without pointing to a screenshot. We don't calculate the speed of a space rocket using horse power, and we shouldn't encourage anyone introducing greek symbols into a programming language that is intented to me more than esoteric.Haskell and haskell derived languages are and will continue to fail to become mainstream, because:- they were not designed with that goal in mind (actual statements of the language designers)- the syntax isn't optimized to limit the cognitive load of actual real world use-cases. Instead, it's optimized to make a fibonacci function look as much like ancient math as possible. Has anyone ever been paid to code that function? No. Is this function particularly difficult to implement in other languages? No.- they pretend computers don't exist. Haskell implementations have operational semantics: they are just under-specified, unpredictable and implementation-specific.  Performance and scalablility don't need to be good; they need to be predictable by a human. The algorithmic complexitiy of any operation, should not became a secret hidden behind a curtain of mystery.- it fails the main challange of large scale software development: coordination state mutations We need standardisation and normalisation of state. Yet by making all state explicit arguments, and being all religious about it, you end with a zillion competing ways to structure and reflect on the state. Knee-deep in monad transformers that convert one type of state to some other type of state, one has to wonder: is it so bad that most programming languages just wrap every computation is one standarized state-monad? No! That's actually a good thing. Let's not pretend that encapsulation of state, can only be done functionally.- The cult surrounding it keeps propagating misconceptions about the nature of computation itself. Take your comment for example:>Ultimately, functional programming lets you talk about what where imperative languages force you to talk about how.This not true. Functional programming does not let you talk about the what. Haskell definately doesn't let you just talk about the what. If i put "e = m * c" into haskell, i won't suddenly get m, given an e. Just because the operational semantics of Haskell are under-specified and incomprehensible by anyone without an academic background, doesn't mean there is no operational semantics. At it's core, it's just a term rewriter with a lot of fine print, that nobody bothered to properly document, and which is far from intuitive.>even concepts like mutable variables and loops are not particularity intuitive.Correct. But combined with term rewriting, dataflow and logic programming, and a bunch of other paradigms the best tools we've got to deal with a wide scenario of our real world use-cases.Functional programming is doing fine. Static type analysis is a great tool and many use it often, but few if any are using it exclusively, because it is the enemy of exploration: A run-time type error, is one that carries real example data!But lazy evaluation, underspecified and unpredictable operational semantics, and foreign alphabets means that the the average can't even verbalize the question you guys don't the answer to.