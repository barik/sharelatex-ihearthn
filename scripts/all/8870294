Heh, that agony description was eerily familiar, and I'd be the employee! The hard part is not being afraid to make an obviously right change, even if it means spending ages manually testing things and then continuing to follow up weeks later when the non-obvious things you didn't think of break :)Even in the face of changing requirements I've found that there are substrates of code that do their job without (showing?) major bugs for years. They never needing fixing. That's your good code. If you had unit tests, you'd never run them anyway because you never touch that code. They are the "select()"s of this world, but specific to whatever you're writing.Now if the whole system had to be rewritten, the old tests would be useless anyway. You mention requirements that have changed, so those tests you had would no longer apply. You'd have to write a new system and new tests ;-)FWIW I've found that peer code review and static analysis tools give you a lot of what unit tests would anyway, without the overhead of having to write the tests and update the dead code when you rewrite the affected part of the system.I mean... what's the point of code anyway? Is it to be "perfect"? Or is it to do a job, earn you money, and be more or less maintainable? Constantly refactoring to stay in the same place is worse than copy-pasting code, from a business owner's POV. Sometimes it is better to have 2 copy pasted methods that are deployed and the customers are happy, than trying to have 1 perfect method sat in development. If those 2 methods never need updating again, you wasted time refactoring. If you would need a third copied method later on, that's the time to refactor.Maybe I'm being a bit devil's advocatey. Unit tests and refactoring are good tools, but they are not "free" (since you have to test the real system anyway at some point) and Uncle Bob is a bit of a snake oil salesman anyway :-P