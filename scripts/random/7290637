Troll harder, greenhorn. (account "metsgrets" created 7 hours ago)> CPAN is awful […] Navigating it is a pain […] the issue tracker is a nightmareThese are opinions. I cannot see any facts to substantiate the claims.> most of the documentation is done very poorly because no one puts time into formatting their readmesNo, most of the documentation is the best among libraries in any programming language because everyone uses documentation templates and then fills in the details in copious amount. These templates have been honed over years, and the docs are regularly quality checked by automated services. It also helps that the documentation format POD is so so stupidly simple that it never gets in the way of work: a programmer spends all the time writing content, none on formatting.> None of the modules are in githubAll of the modules are in Github.> the links make no sense ( "Source (raw) Browse (raw)" )"Source" shows the module's source (HTML, syntax highlighted). "Browse" browses the directory structure of the unpacked distribution. The raw links are the plain text equivalents served by the API primarily for programmatic access. All of this is readily obvious by just following a link.> many of the modules we have worked with have bugs and poor documentationUnsubstantiated, no details.> and almost all of them are unmaintainedCPAN freshness tells a different story.> owners either gave up or actually diedThere's a process in place for taking over maintenance. It is used a couple of times a month.> There is absolutely no support for trying to do common tasks with CPAN modulesWrong. Any common task has several modules.> You can't Google for your errorUnsubstantiated, no details.> you won't get a response on StackOverflowWrong. Unanswered quota is only 10%.> CPAN is just messy all aroundSame is true for any file archive. Show me a programming language where this is not the case. At least it's centralised, not strewn across the Web! On top of the archive, curated indexes such as http://p3rl.org/Task::Kensho exist.> There's not even a command line flag to find out what version of a module you have installed. You have to hack into its internals to figure out what versions you're running.Wrong.    $ pmvers Catalyst\n    5.90060\n\n    $ perl -MCatalyst -E'say Catalyst->VERSION'\n    5.90060\n\n> Some modules are hosted in foreign countries that intermittently decide not to download. Builds have broken due to inability to download from a mirror.Then pick a mirror near you. http://mirrors.cpan.org/ The standard CPAN client does this automatically during first run.> The only known benefit of CPAN - automated test running, has never once proved helpful.Unsubstantiated, no details.> It seems like Larry Wall (creator of Perl) has a no-one-likes-this-langauge-so-try-to-please-everyone-by-offering-every-way-to-do-it complex.Wrong, this is because humans have different ways to think and preferences how to express themselves. The programming language works with the grain of the human mindset, not against it. http://c2.com/cgi/wiki?ThereIsMoreThanOneWayToDoIt> I have to Google for how to iterate over a hash every time, because there's multiple ways to do it, and they all suck. I never know if iterating over a $hash is the same as iterating over a %hash or a \\%hash.Then you know less than a beginner in his third lesson.    ⎆ my %hash = qw(a b c d); my $hash = \\%hash\n    ⎆ while (my ($key, $value) = each $hash) { say "$key => $value" }\n    a => b\n    c => d\n    ⎆ while (my ($key, $value) = each %hash) { say "$key => $value" }\n    a => b\n    c => d\n    ⎆ while (my ($key, $value) = each \\%hash) { say "$key => $value" }\n    a => b\n    c => d\n\n> if I should be searching for "hash" or "hashref" or if I should be using a "list" or an "array" or a scalar or who caresOnly bash and Tcl free you from thinking about and selecting the appropriate data type.> The multiple ways to do things only amounts to one asshole on the team will exploit some unknown feature of map to write shorter code, not document it, and no one can read it.This is a social problem, and not the responsibility of the programming language or its designer. Anyone can write crap code in any language. Enforce code style and policy locally. Static analysis tools like http://p3rl.org/perlcritic exist. Apply them.> Perl is not efficientPerl remains the fastest of the scripting languages.> Beauty is subjective, readable code is not.Unreadable code is a social problem across all programming languages. This has nothing to do with Perl per se.> The prefixing of variable names with @, % et all makes dissecting code hardWrong, sigils make the nouns stand out, just like capitalisation in written German. Both empirically make reading faster and comprehension easier.> Googling impossibleWrong. It is true that search engines drop sigil characters from the query, but the context words still find the result in the index.> References are one of, if not the, biggest design flaw in Perl […] make reading and writing code confusing, overly complicatedUnsubstantiated, no details.> haven not once offered us any benefitWrong, as references are the basis for objects (OOP).> the language is gross. It has magic built in, and the syntax is a nightmareUnsubstantiated, no details.> You get function arguments as @_Concept stolen from Shell, already remedied in version 20. Signatures have been available for years with modules.> You do a regex match with $string =~ /(capture)/. This will magically populate $1 through $n with capture groups. This is bad.Agreed, side effects are evil. That's the legacy interface and impossible to deprecate/remove. The expression will also return a list of the captures which you can then assign or mangle as you wish.    my @results = $string =~ /(capture)/\n\nGood style dictates to prefer this interface.> $string =~ s/a/b. This modifies the string in place. Try to Google for how to not modify the string in place. Seriously, try and Google for it.Yes, and?    g perl substitute return modification\n\n(Type it out to see Google suggestion/autocompletion.) First five results all teach:    my $new = $string =~ s/a/b/r\n\n> If you forget to include an even number of values in a list it becomes another data structure entirely.Wrong, a list is a list no matter how many elements.> If you don't put a '1;' at the end of your module code it will fail to work (no, really).Valid complaint. Again, it's too late to fix it because existing code needs to keep working, back-compat is serious business for perl5-porters. New projects with modern Perl just avoid the need for that last line: http://p3rl.org/true> bless […] but it still is out of place in a programming language.The word is religion neutral. Your biases show.> The "features" of Perl ruin it for a team environment.Unsubstantiated, no details.